"""arXiv TeX produced routines."""

import re
import subprocess
import os
from typing import List

from filemanager.arxiv.file import File

# Note: may want to pass around File object

verbose = 0

def get_filtered_pdf_info(filepath: str) -> List[str]:
    """
    Returns select set of values from pdfinfo output for specified file.

    Parameters
    ----------
    filepath : str
        The file to run pdfinfo on.

    Returns
    -------
    List containing one entry for each selected line from pdfinfo output.

    """
    info = subprocess.run(["pdfinfo", f"{filepath}"], stderr=subprocess.PIPE,
                          stdout=subprocess.PIPE)

    lines = info.stdout.splitlines()

    info_list = []

    # Filter for only those elements we are checking
    for line in lines:
        if re.search(rb'^(Creator:|Producer:|Title)', line):
            info_list.append(line)

    return info_list

def get_pdf_fonts(filepath: str) -> List[str]:
    """
    Return the list of fonts for specified file.

    Parameters
    ----------
    filepath : str
        The file to run pdffonts on.

    Returns
    -------
    List containing one entry for each line of output from pdffonts command.

    """
    info = subprocess.run(["pdffonts", f"{filepath}"], stderr=subprocess.PIPE,
                          stdout=subprocess.PIPE)

    lines = info.stdout.splitlines()

    fonts_list = []

    for line in lines:
        fonts_list.append(line)

    return fonts_list


# Regular expressions that indicate TeX Produced (for pdfinfo)

regex1 = re.compile(br"^Creator.*dvips", re.IGNORECASE)
regex2 = re.compile(br"^Title.*\.dvi", re.IGNORECASE)
regex3 = re.compile(br"^(Creator|Producer).*TeX(?!(t|macs-1\.))", re.IGNORECASE)
regex4 = re.compile(br"^(Creator|Producer).*dvipdfmx?", re.IGNORECASE)
regex5 = re.compile(br"^(Creator|Producer).*cairo.*$", re.IGNORECASE)

regexes = [regex1, regex2, regex3, regex4, regex5]

# Ignore this case where wisywig sotware uses TeX for back end processing.
regexTeXmacs = re.compile(br"^(Creator|Producer).*TeXmacs-1\.", re.IGNORECASE)

# PDFs using Cairo or CMR/RTX fonts were generated by TeX
fontsrgex = re.compile(br"^CairoFont\-\d-\d|^\S+\+(?:cmr|rtx)", re.IGNORECASE)



def check_tex_produced_pdf(file_path: str) -> bytes:
    """
    Check whether specified PDF file was produced by TeX.

    Parameters
    ----------
    file_path : str
        The file path for PDF to be checked for TeX produced.

    Returns
    -------
        String (regex match) if PDF is TeX-produced, otherwise return ''.

    """
    if not os.path.exists(file_path):
        return b''

    info = get_filtered_pdf_info(file_path)

    if verbose:
        print(f"\nInfo: '{info}' from PDF")

    for regex in regexes:
        ret = [m.group(0) for i in info for m in [regex.search(i)] if m]
        if ret:
            return ret[0]

    # Skip fonts check when TeXmacs (uses TeX as its backend)
    ret = [m.group(0) for i in info for m in [regexTeXmacs.search(i)] if m]
    if ret:
        return b''

    # Check for TeX fonts
    fonts = get_pdf_fonts(file_path)

    match = [m.group(0) for i in fonts for m in [fontsrgex.search(i)] if m]

    if match:
        return match[0]

    return b''


def check_tex_produced_ps(file_path: str) -> bytes:
    """
    Check whether specified Postscript file was produced by TeX.

    Parameters
    ----------
    file_path : str
        The file path for Postscript file to be checked for TeX produced.

    Returns
    -------
    string
        Returns string (regex match) if Postscript file was produced by TeX.

    """
    if not os.path.exists(file_path):
        return b''

    TEX_GREP = fr'TeXdict|dvit?ps|ArborText|OzTeX|PCTEX|^%.VTeX|' \
               fr'^%%Creator:.*Textures|^%%Title: .*\.dvi\b'
    out = subprocess.run(f"head -500 {file_path} | egrep -i '{TEX_GREP}' | head -1",
                         stderr=subprocess.PIPE,
                         stdout=subprocess.PIPE,
                         shell=True)

    if out.stdout:
        return bytes(out.stdout)

    out = subprocess.run(f'head -2000 {file_path}' + '| egrep -i "[A-Z]{5,6}\\+CMR10"| head -1',
                         stderr=subprocess.PIPE,
                         stdout=subprocess.PIPE,
                         shell=True)

    if out.stdout:
        return bytes(out.stdout)

    return b''

#
# It's not clear this routine/code belongs here since the logic needs to tie
# in with (add to) the list of errors. This might make more sense rolling into the
# upload checks side of things.
#
def check_tex_produced(file_list: List[File]) -> bool:
    """
    Check whether PS/PDF file was produced by TeX.

    Parameters
    ----------
    file_list : list
        List of submission files to check for TeX produced.

    Returns
    -------
    bool    True if we detect TeX produced file.

    """
    for file_obj in file_list:

        if file_obj.type == 'pdf':
            tex = check_tex_produced_pdf(file_obj.filepath)
        elif file_obj.type == 'postscript':
            tex = check_tex_produced_ps(file_obj.filepath)
        elif file_obj.type == 'dvi':
            tex = b'a DVI file'

        if tex:
            # Generate error message for file

            # Generate TeX Produced error (only once)

            return True

    return False
